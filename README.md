# LiBox: High-Performance Learned Index Data Structure

LiBox is a high-performance learned index data structure optimized for modern multi-core CPUs with SIMD support. It combines machine learning techniques with traditional indexing methods to achieve superior performance for key-value storage and retrieval operations.

## Features

- **SIMD-Optimized Operations**: Leverages AVX-512 instructions for parallel data processing
- **Learned Index**: Uses linear interpolation for fast segment location
- **Multi-Level Architecture**: Three-tier design (Segment → Box → Overflow) for efficient data organization
- **High Concurrency**: Thread-safe operations with atomic version control
- **Dynamic Splitting**: Automatic segment splitting when capacity limits are reached
- **Adaptive Partitioning**: Intelligent segment configuration generation

## Requirements

- **CPU**: x86-64 processor with AVX-512 support
- **Compiler**: GCC 7.0+ with C++17 support
- **Dependencies**: OpenMP

```bash
# Ubuntu/Debian
sudo apt-get install build-essential libomp-dev

# CentOS/RHEL
sudo yum install gcc-c++ libomp-devel
```

## Getting Started

LiBox consists of three main components:
- **libox.h**: Core learned index library with insert, search, and range query functionality
- **libox_utils.h**: Utility functions for resegment partitioning and optimization
- **partition_optimization.cpp**: Data analysis tool for generating optimal configuration files

### Build

```bash
# Clone the repository
git clone https://github.com/yourusername/libox.git
cd libox

# Build benchmark (creates test/benchmark)
make

# Build optimization tool
make all

# Build debug versions
make debug

# Clean build artifacts
make clean
```

### Step 1: Generate Configuration File (Optional)

Use the partition optimization tool to analyze your dataset and generate an optimal configuration:

```bash
# Analyze your dataset and generate configuration
./test/partition_optimization \
--input_file=/path/to/your/dataset.csv \
--output_config=generated_config.csv
```

Or use the provided sample configuration for quick testing.

### Step 2: Run Benchmark

#### Quick Start with Sample Data

```bash
# Run benchmark with sample data (small dataset for quick testing)
./test/benchmark \
--keys_file=sample/sample_keys.txt \
--keys_file_type=text \
--config_file_path=sample/sample_config.csv \
--init_num_keys=1000 \
--total_num_keys=2000 \
--batch_size=1000 \
--insert_frac=0.5 \
--thread_num=1 \
--print_batch_stats
```

#### Running with Large Datasets

```bash
./test/benchmark \
--keys_file=/path/to/your/dataset.csv \
--keys_file_type=text \
--config_file_path=generated_config.csv \
--init_num_keys=350000 \
--total_num_keys=700000 \
--print_batch_stats \
--insert_frac=0.5 \
--batch_size=200000 \
--thread_num=4 \
```

## Core Components

### libox.h - Core Library

The main header file contains the complete LiBox implementation with all core operations:

```cpp
#include "libox.h"
#include "libox_utils.h"

using namespace liboxns;

// Initialize LiBox with core functionality
TaskQueue splitQueue;
LiBox<uint64_t, uint64_t> index;
index.init(underflowThreshold, overflowThreshold, &splitQueue, thread_count);

// Load configuration (generated by partition_optimization or manual)
index.loadConfigByFile("config.csv");

// Core operations
index.insertKeyValue(key, value);           // Insert operation
auto result = index.searchKey(key);         // Point search
auto range_result = index.rangeSearch(start, end);  // Range query
size_t count = index.scan(key_bound, max_count, results);  // Scan operation
```

### libox_utils.h - Utility Functions

Contains utility functions for resegment partitioning and optimization algorithms used by the core library.

### partition_optimization.cpp - Configuration Generator

This tool analyzes your dataset characteristics and generates optimal segment configurations:

- Analyzes key distribution patterns
- Calculates optimal segment boundaries  
- Determines appropriate box ranges for each segment
- Outputs optimized configuration file

## Architecture

LiBox employs a three-tier hierarchical structure with intelligent resegment capabilities:

```
┌─────────────────────────────────────────────────────────┐
│                      LiBox                              │
│                (with resegment support)                 │
├─────────────────────────────────────────────────────────┤
│  Segment 1    │  Segment 2    │  ...  │  Segment N      │
│  (adaptive)   │  (adaptive)   │       │  (adaptive)     │
├─────────────────────────────────────────────────────────┤
│  Box 1 │ Box 2│  Box 1 │ Box 2│       │  Box 1 │ Box 2  │
├─────────────────────────────────────────────────────────┤
│  OverflowKeyValue Arrays (when boxes are full)         │
└─────────────────────────────────────────────────────────┘
```

### Key Features

- **Adaptive Resegmentation**: Automatic segment splitting and merging based on load
- **Learned Index**: Linear interpolation for O(1) segment location
- **SIMD Optimization**: AVX-512 accelerated operations in all components
- **Concurrent Access**: Lock-free operations with atomic version control

## Benchmark Parameters

| Parameter | Description | Example Values |
|-----------|-------------|----------------|
| `--keys_file` | Path to input dataset file | `sample/sample_keys.txt` |
| `--keys_file_type` | File format (text/binary) | `text` |
| `--config_file_path` | Path to segment configuration | `sample/sample_config.csv` |
| `--init_num_keys` | Initial number of keys to load | `1000000` |
| `--total_num_keys` | Total keys in dataset | `2000000` |
| `--batch_size` | Operations per batch | `10000` |
| `--insert_frac` | Fraction of insert operations | `0.5` (50% inserts) |
| `--thread_num` | Number of threads | `4` |
| `--print_batch_stats` | Enable detailed statistics | (flag) |

## Configuration File Format

The configuration file defines segments in CSV format (can be generated by partition_optimization tool):

```csv
lower_bound,upper_bound,box_range
0,10000,100
10001,50000,200
50001,100000,500
```

Each line specifies:
- **lower_bound**: Starting key value for the segment
- **upper_bound**: Ending key value for the segment  
- **box_range**: Key range per box within the segment

## Sample Data Files

The `sample/` directory contains example files for quick testing:

### sample/sample_keys.txt
```
1
2
3
4
5
...
2000
```

### sample/sample_config.csv
```
0,500,50
501,1000,50
1001,2000,100
```

## Workflow Examples

### For New Datasets

1. **Analyze and Generate Configuration**:
   ```bash
   ./test/partition_optimization --input_file=your_data.csv --output_config=optimized_segment.csv
   ```

2. **Run Benchmark**:
   ```bash
   ./test/benchmark --keys_file=your_data.csv --config_file_path=optimized_segment.csv --keys_file_type=text --init_num_keys=1000000 --total_num_keys=2000000
   ```

### For Quick Testing

1. **Use Sample Data**:
   ```bash
   ./test/benchmark --keys_file=sample/sample_keys.txt --config_file_path=sample/sample_config.csv --keys_file_type=text --init_num_keys=1000 --total_num_keys=2000
   ```

## Performance Optimizations

- **SIMD Acceleration**: AVX-512 instructions for parallel operations
- **Cache-Friendly Layout**: 64-byte aligned data structures
- **Adaptive Resegmentation**: Dynamic load balancing
- **Lock-Free Operations**: Atomic version control for high concurrency
- **Intelligent Partitioning**: Data-driven segment optimization